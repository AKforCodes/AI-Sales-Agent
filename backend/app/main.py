from fastapi import FastAPI, HTTPException
from app.schemas.quote import ProductInquiry, QuoteResponse
from app.agent_logic import agent_executor
import json
import re
from fastapi.middleware.cors import CORSMiddleware # <--- ADD THIS IMPORT

app = FastAPI(
    title="AI Sales Agent API",
    description="An API for interacting with an autonomous AI sales agent."
)

# --- ADD THIS ENTIRE MIDDLEWARE BLOCK ---
# This allows your frontend (running on localhost:3000) to communicate with your backend.
origins = [
    "http://localhost",
    "http://localhost:3000",
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"], # Allows all methods (GET, POST, OPTIONS, etc.)
    allow_headers=["*"], # Allows all headers
)
# --- END OF NEW BLOCK ---

@app.get("/", summary="Root endpoint to check service status")
def read_root():
    """Returns a simple message to indicate that the service is running."""
    return {"message": "AI Sales Agent is running."}


@app.post("/quote", response_model=QuoteResponse, summary="Get an AI-generated product quote")
async def get_quote(inquiry: ProductInquiry):
    """
    Receives a product inquiry and returns a full quote generated by the AI agent.

    The agent will:
    1. Search for the product.
    2. Generate a quote with pricing and stock info.
    3. Log the quote to history.
    4. Return a natural language summary and a structured JSON invoice.
    """
    try:
        agent_input = {"input": inquiry.query}
        # We create an empty chat history for each new request
        if "chat_history" not in agent_input:
             agent_input["chat_history"] = []
        agent_response = await agent_executor.ainvoke(agent_input)
        output_text = agent_response['output']

        # Use regex to find the JSON blob
        json_match = re.search(r"```json\s*(\{.*?\})\s*```", output_text, re.DOTALL)

        if not json_match:
            # If no JSON quote is found, it's a conversational response.
            # Return the full text as the summary and no invoice.
            return QuoteResponse(
                natural_language_summary=output_text,
                invoice_json=None
            )

        # If a JSON block is found, parse it as before.
        natural_language = output_text[:json_match.start()].strip()
        json_string = json_match.group(1)
        invoice_data = json.loads(json_string)

        return QuoteResponse(
            natural_language_summary=natural_language,
            invoice_json=invoice_data
        )

    except Exception as e:
        print(f"An error occurred in /quote endpoint: {e}")
        raise HTTPException(status_code=500, detail=str(e))
